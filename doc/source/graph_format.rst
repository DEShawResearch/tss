Graph construction
------------------

``GraphBuilder`` reads an ark file specifying a TSS graph and produces an expanded, unambiguous representation of its rungs and windows, and optionally nodes and edges. The expanded representation is frequently large (thousands of lines), so is stored in its own *graph.ark* file. 

========================
Specifying a TSS graph
========================
The graph generator reads the ``integrator.times_square`` block. The ``edges`` block contains most of the input. Only the parts relevant to the generator are shown here. 

For a guide to the significance of these parameters, consult the TSS manuscript. 

Sample input::

    integrator {
        times_square {
            edges = [{
                nodes = ["cold" "hot"]
                dimensions = "1"
                number_of_rungs = "100"
                window_size = "20"
                primary_window_tiling_only = "false"
                schedule = [{
                    group_name = "temp_vals"
                    interpolation = "linear"
                    bounds = ["278" "400"]
                    dimension = "0"
                }
                ...
                ]
            }
            ...
            ]
            blocks = {
                count = 1
            }
        }
    }

---------------
Edge dimension
---------------

Edges can have arbitrary dimension. ``nodes`` must be a d-dimensional nested array that matches the dimension specified by ``dimensions``. If ``dimensions`` is omitted, the default is 1. Node names cannot be repeated within an edge, except for the special nodename "_" which results in an autogenerated nodename. 

---------------------
Rung and window size
---------------------
``number_of_rungs`` and ``window_size`` are lists whose length must be equal to ``dimensions``. Windows are objects with the same dimensionality as the window. Within an edge, all windows have the same size, and ``window_size`` is the number of rungs in each dimension. Exception: windows at the ends are half-size in the end dimension(s).

``window_size`` must evenly divide ``number_of_rungs``, and there are additional compatibility requirements for multi-edge graphs to ensure that joins can be performed. The generator will produce an error if ``window_size`` is invalid. 

----------
Schedules
----------
Each edge can specify an arbitrary number of parameters. 

- ``group_name`` should correspond to a ``feature_name`` in ``integrator.times_square.features``. 
- ``interpolation`` specifies how to generate numeric values of this feature for each rung. Choices are ``linear``, ``geometric``, ``geometric_increment``, ``polynomial``, ``piecewise``, or ``explicit``. The default is ``linear``. 
- ``bounds``: for linear, polynomial, and geometric interpolation, ``[start stop]``. For geometric_increment, ``[start stop bias]]``. For piecewise, ``[b0 b1 b2 ...]`` With n entries in the bounds array, the rungs are divided into (n - 1) equal-length sections. The middle entries in the bounds array will each be used on two rungs: end of one segment and start of the next. For explicit, a list of the same length as the number of rungs (no interpolation is performed; these values are used directly).
- ``degree``: for polynomial interpolation, the degree of the polynomial to be used. Default is 2. 
- ``dimension``: along which dimension of the *edge* should this schedule vary? The default is 0. 

---------------------
Additional settings
---------------------
- ``primary_window_tiling_only`` is an expert-mode setting that should be left at the default (False) for most users. If True, it generates only one set of windows and not the second (overlapping) set of windows. This will prevent cross-edge joins involving this edge and may lead to a disconnected graph, so probably useful only for single-edge graphs. 

-------------------------------
Multi-edge graphs and joining
-------------------------------
When multiple edges are specified in a graph, typically the goal is to produce a single connected component where the edges are connected at particular nodes. Edges can be joined at a point (for 1-D graphs) or along a line (for 2-D graphs). Join locations are automatically computed based on matching ``node`` labels. 

For instance, when two edges share a node labeled ``join_me``, an overlap window will be produced at that location including the border rungs from each edge. The parameters of the end rungs must be identical. If a schedule is specified for one edge but not the other, the constant boundary value will be propagated to all rungs in the second edge. 

=============================
The expanded representation
=============================

The expanded spec is designed for several goals:

1. Explicit so that runtime estimator don't need to make extensive inferences
2. Unambiguous when later analysis is performed

The expanded spec contains the following items:
    
#. Rungs as an ordered list, where each rung has

       #. name: an optional name, as free text
       #. flat_index: the integer position of the rung in the list of rungs
       #. parameters: the names of all parameters tuned on the graph and their numeric values, as a dictionary
       #. neighbors_dimensional (for coordinate invariance): for each of the n tuned parameters, the rung's previous and next neighbor rungs specified by their indices in the list, excluding any neighbors in a different edge, as an unordered list of (before, after) tuples
       #. edge_id: (optional) the index of the edge in the edge list containing this rung (each rung can belong to only one edge, though two rungs on different edges can be joined at a node if their parameters are equivalent), as an integer
       #. location: (optional): integer coordinates giving the position of this rung within its n-dimensional edge, as an array of length n
       #. volume: float giving the volume in lambda space of the rung and its region. All non-boundary rungs have equal volume; all boundary rungs have relative volume (1/2)^d where d is the number of dimensions on its edge. 

#. Windows as an ordered list, where each window has

    #. rung_set: an unordered list of m arrays. The arrays are of identical shape and each has n dimensions. Each array element is a rung index. Moves between rungs within an array can be antithetic. Moves between arrays can only be independent.

        * Example: a 1-D window not containing a node is represented as [[1,2,3]]
        * Example: a 1-D window containing a node (and therefore stretching across two edges, so only independent moves are allowed) is represented as [[1], [2], [3]]

        * Example: a 2-D window containing a node and a shadow node is represented as [[1, 2, 3], [4, 5, 6], [7, 8, 9]], where each array is a slice of the graph along a dimension that cannot cross a node

        * Example: a 2-D window containing no nodes is represented as [[[1, 2, 3], [4, 5, 6]]] â€“ note that this is a list of length 1 of a 2d array (total 3 dims in this list)

#. Nodes (optional) as an ordered list, where each node has

    #. name: an optional name, as free text
    #. rung_set: a set of rung indices that have equal parameters and are all to be considered part of the node

#. Edges (optional) as an ordered list, where each edge has

    #. name: an optional name, as free text
    #. node_set: the set of 2^n boundary node names as a n-dimensional array

======================
Usage example
======================

The sample arks in the tests directory of this repository exercise many features of the generator. 

A usage example of the ``GraphBuilder`` API is shown here::

    import ark
    from tss import GraphBuilder

    gb = GraphBuilder()

    ######
    # 1. Add edges
    edge_id0 = gb.add_edge(['A', 'B'], [36], [12])

    # the _ indicates the node will be auto-named
    # the two edges will be joined at node B since it is mentioned twice
    edge_id1 = gb.add_edge([['B', 'C'], ['_', '_']], [36, 18], [12, 6], dimensions=2)

    ######
    # 2. Add schedules on the edges. Where edges are joined, parameter
    # values will be propagated so that every rung has a value of each parameter. 
    # 
    # Each dimension of each edge can have as many parameters as you like. 

    gb.add_schedule(edge_id0, 'param_cranberry', 'linear', [0, 50])
    gb.add_schedule(edge_id1, 'param_pineapple', 'linear', [0, 75], dim=0)
    gb.add_schedule(edge_id1, 'param_orange', 'linear', [-0.1, -0.8], dim=1)
    gb.add_schedule(edge_id1, 'param_clark', 'geometric', [1, 128], dim=1)

    ######
    # 3. Construct the graph. At this point no more edges can be added. 
    gb.build()

    ######
    # 4. Add blocks (optional)
    gb.add_blocks(3)

    ######
    # 5. Serialize

    gb.cerealize('graph.ark') 

=================
API reference
=================

.. autoclass:: tss.GraphBuilder
       :members:
